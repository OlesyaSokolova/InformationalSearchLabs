1. Каким образом вставить РНР-команды в HTML-программу?
<?php .... ?> вставить спец теги

2. Для чего используются динамические переменные и ссылки на переменные?
Их содержимое может динамически интерпретироваться как имя другой переменной.
Таким образом, выражения присваивания
$client = "user"; $$client = "Nic";
эквивалентны следующей записи
$user = "Nic";
В переменной $client записана строка "user", поэтому можно представить себе,
что выражение $$client — это знак $, за которым следует значение переменной $client.
Все вместе РНР интерпретирует это как $user.

3. Каким образом можно изменить или преобразовать тип переменной?
Существует функция settype(), служащая для изменения типа переменной.
Для того чтобы изменить тип переменной, вы должны при вызове этой функции указать переменную,
тип которой вы хотите изменить, и новый тип данной переменной.
$var = 3.14;
print gettype($var);    // double
print " - $var<br>";    // 3.14
settype($var, "string");
print gettype($var);    // string
print " - $var<br>";    // 3.14

4. Назовите операторы, предназначенные для работы со строковыми переменными.
В PHP есть два оператора для работы со строками (string).
    1. Первый - оператор конкатенации ('.'), который возвращает строку,
представляющую собой соединение левого и правого аргумента.
    2. Второй - оператор присваивания с конкатенацией ('.='),
который присоединяет правый аргумент к левому.

5. В чем заключается разница между циклами while, do..while и for ?
    1. while (выражение) {
              // тело цикла
       }

       До тех пор, пока выражение в скобках истинно, тело цикла выполняется.
Как правило, при этом некоторым образом изменяется какая-то переменная или переменные
от которых зависит значение выражения в скобках. Если такой зависимости нет,
то цикл будет выполняться бесконечно.

    2. Цикл do..while

       Цикл do..while напоминает цикл while, перевернутый с ног на голову. Разница состоит в том, что цикл do..while сначала выполняется, а потом проверяется истинность его условия (совершенно аналогично циклу repeat..until языка Паскаль).

       do {
           // тело цикла
           }
       while (выражение);

    Тестовое выражение цикла do..while обязательно должно заканчиваться точкой с запятой.
Этот цикл может быть полезен в том случае, если вам нужно, чтобы его тело выполнилось
хотя бы один раз, независимо от значения тестового выражения.

    Цикл for отличается от цикла while только тем, что условие изменяется в самой управляющей конструкции, а не где-то внутри блока команд. Цикл for выполняется до тех пор, пока проверяемое условие остается истинным.

    for (инициализация;  условие;  приращение)
        {
         //тело цикла
        }

    Выражения в скобках должны быть разделены точками с запятой.
В первом выражении счетчику цикла присваивается некоторое начальное значение (инициализация),
во втором выражении проверяется условие цикла,
а в третьем выражении происходит увеличение или уменьшение счетчика.

6. Как можно прервать цикл или пропустить текущую итерацию?
    1. Прерывание циклов командой break
В циклах for и while присутствует условие, которое определяет продолжительность выполнения цикла.
Однако такое выполнение можно прервать досрочно с помощью команды break.
Как правило, для этого проверяется некоторое дополнительное условие.
Это обычно делается при обнаружении ошибочного состояния.

    2.Пропуск итераций с помощью команды continue

    Команда continue служит для пропуска текущей итерации цикла,
но не прерывает выполнение цикла окончательно. В результате ее выполнения программа
 переходит к следующему значению счетчика цикла.

7. Опишите разные способы передачи аргументов внутрь функции, объяснив их различие.
    PHP поддерживат:
    1. передачу аргументов по значению (по умолчанию),
    2. передачу аргументов по ссылке,
    3. значения по умолчанию.
    4. Списки аргументов переменной длины и именованные аргументы также поддерживаются.

8. Что такое функции-переменные?
Имя функции можно присвоить некоторой строковой переменной,
а затем обращаться с этим именем точно так же, как с самой функцией.

9. Назовите особенности ассоциативных массивов.
    1. В ассоциативных массивах элемент указывается не по номеру, а по имени.
    2. Апострофы у названий ключей при создании ассоциативного массива использовать обязательно.
    3. $sal = array (
       'name' => "Peel",
       'city' => "London",
       'comm' => 0.12
       );
       Теперь можно обратиться к любому элементу массива:
       print $sal['name'];
    4. $sal['name'] = "Peel";
       $sal['city'] = "London";
       $sal['comm'] = 0.12;

10. Какая конструкция предназначена для просмотра ассоциативных массивов в цикле?
К ассоциативным массивам в PHP применим только один вид циклов — foreach.
Причём он работает одинаково для индексированных и ассоциативных массивов.
$course = ['name' => 'JS: React', 'slug' => 'js-react'];
foreach ($course as $key => $value) {
    print_r("{$key}: {$value}");
}
// => name: JS: React
// => slug: js-react

Если ключ не нужен, то часть $key => можно опустить и тогда цикл станет таким:
<?php
foreach ($course as $value) {
    print_r($value);
}

11. Опишите функции сортировки массивов, объяснив их различие.

    1. Сортировка простого массива с помощью функции sort()
Функция sort() принимает один аргумент — массив — и сортирует его:
в алфавитном порядке, если хотя бы один из его элементов является строкой,
и в числовом порядке, если все его элементы — числа.
Эта функция преобразует переданный массив и ничего не возвращает.
Не передавайте функции sort() ассоциативные массивы — в противном случае вы увидите,
что массив отсортирован правильно, но все его имена будут утеряны и вместо них сохранены числа.

    2. Простые массивы можно сортировать в обратном порядке.
Для этого существует функция rsort(), которая работает точно так же, как и функция sort().

    3. Функция ksort() принимает аргументом ассоциативный массив
и сортирует его по именам полей. Она преобразует сортируемый массив и ничего не возвращает.

    4. Для того чтобы отсортировать массив в обратном порядке,
нужно воспользоваться функцией krsort(), которая работает точно так же.

